# Rust 代码分析系统：死锁与数据竞争检测

## 1. 概述

采用 Petri 网和锁图技术分析 Rust 代码中的死锁问题，同时结合 sanitizer 技术分析数据竞争。系统的分析流程从生成当前 crate 的函数调用图开始，进一步通过指针分析来确保转换过程中锁对象的正确指向。最终分析包括基于锁图的死锁检测和基于 Petri 网的状态可达图分析。

## 2. 死锁检测

### 2.1 函数调用图生成

对于待分析的 crate，系统首先生成函数调用图，该图是后续分析的基础。此图涵盖 crate 内部所有函数的调用关系，确保后续分析的完整性。

` src/callback.rs文件中可以输出 callgraph.dot 文件`

### 2.2 指针分析

使用指针分析来追踪不同锁对象之间的指向关系。此步骤对于确定锁的使用范围和潜在的死锁检测至关重要。

### 2.3 死锁检测方法

#### 2.3.1 锁图分析

在函数调用图和指针分析的基础上，利用锁图技术进行直接的死锁检测。此方法通过分析可能的锁获取顺序和锁释放模式，识别潜在的死锁风险。

对比 lockbud 改进如下：


#### 2.3.2 Petri 网分析

基于函数调用图和指针分析，将分析内容转换为 Petri 网模型。此模型仅转换 crate 内部的函数以及包含中间代码的函数，以降低复杂度。通过生成状态可达图来分析死锁状态。注意，如果已有一个死锁状态发生，则后续死锁状态将不可达，因此不会被检测。

对比 cargo-check-deadlock改进如下：


## 3. 数据竞争检测

由于 Petri 网的转换涉及复杂的数据流控制，我们采用基于 sanitizer 的方法进行数据竞争检测。目前已经封装了 sanitizer 进行初步测试，并计划根据调用关系自动生成针对 `unsafe` 代码的测试用例。
