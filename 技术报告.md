# Rust死锁与数据竞争检测技术报告

## 1. 概述

采用 Petri 网和锁图技术分析 Rust 代码中的死锁问题，同时结合 sanitizer 技术分析数据竞争。系统的分析流程从生成当前 crate 的函数调用图开始，进一步通过指针分析来确保转换过程中锁对象的正确指向。最终分析包括基于锁图的死锁检测和基于 Petri 网的状态可达图分析。

## 2. 死锁检测

### 2.1 函数调用图生成

对于待分析的 crate，系统首先生成函数调用图，该图是后续分析的基础。此图涵盖 crate 内部所有函数的调用关系，确保后续分析的完整性。

` src/callback.rs文件中可以输出 callgraph.dot 文件`

### 2.2 指针分析

使用指针分析来追踪不同锁对象之间的指向关系。此步骤对于确定锁的使用范围和潜在的死锁检测至关重要。

### 2.3 死锁检测方法

#### 2.3.1 锁图分析

在函数调用图和指针分析的基础上，利用锁图技术进行直接的死锁检测。此方法通过分析可能的锁获取顺序和锁释放模式，识别潜在的死锁风险。

对比 lockbud 改进如下：
<<<<<<< HEAD
=======
1. 扩展lockbud实现了过程间的指针分析
2. 改进检测和条件变量相关死锁的算法
3. 使用类型推断不同函数间的指向关系
4. 排除比较常见的误报类型，比如有共同的锁保护（门锁）、join()导致不会并发执行等
>>>>>>> d874e3ca5f30268ab308474e203cb4026e30b614


#### 2.3.2 Petri 网分析

基于函数调用图和指针分析，将分析内容转换为 Petri 网模型。此模型仅转换 crate 内部的函数以及包含中间代码的函数，以降低复杂度。通过生成状态可达图来分析死锁状态。注意，如果已有一个死锁状态发生，则后续死锁状态将不可达，因此不会被检测。

对比 cargo-check-deadlock改进如下：
<<<<<<< HEAD

=======
1. 与cargo集成，可分析整个crate而不是单个文件
2. 基于指针分析，保证转换正确性
3. 基于状态可达图，定义终止状态，并输出死锁位置
>>>>>>> d874e3ca5f30268ab308474e203cb4026e30b614

## 3. 数据竞争检测

由于 Petri 网的转换涉及复杂的数据流控制，我们采用基于 sanitizer 的方法进行数据竞争检测。目前已经封装了 sanitizer 进行初步测试，并计划根据调用关系自动生成针对 `unsafe` 代码的测试用例。
<<<<<<< HEAD
=======


## 下一个版本将支持
1. 基于Petri网和锁图的分析都是基于函数调用图和指针分析，对于异步函数的支持还存在缺陷，后续课题异步时序检测中将会构造新的函数调用关系来建模异步函数，并进一步优化指针分析的精度。
2. 数据竞争一般会导致内存问题，主要发生在unsafe代码块中，后续会增加对于unsafe模块的自动测试用例生成，提高性能。
3. 对于并发bug中非死锁的数据竞争和时序逻辑错误，将采用测试的方法，构造可选的测试引擎，包括loom和afl等，基于给定的bin或者lib包自动构造测试用例。